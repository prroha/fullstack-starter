/**
 * Prisma Schema Merger Utility
 *
 * Merges multiple Prisma schema models from different features into a single schema.
 * Handles model definitions, enums, and relations.
 */

import fs from "fs/promises";
import path from "path";

export interface SchemaMappingConfig {
  model: string;
  source: string;
}

export interface MergeResult {
  schema: string;
  models: string[];
  enums: string[];
}

/**
 * Base Prisma schema with generator and datasource
 */
const BASE_SCHEMA = `// Prisma Schema - Generated by Xitolaunch
// This schema was generated based on your selected features

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

`;

/**
 * Extract model name from a Prisma model block
 */
function extractModelName(modelBlock: string): string | null {
  const match = modelBlock.match(/^model\s+(\w+)\s*\{/m);
  return match ? match[1] : null;
}

/**
 * Extract enum name from a Prisma enum block
 */
function extractEnumName(enumBlock: string): string | null {
  const match = enumBlock.match(/^enum\s+(\w+)\s*\{/m);
  return match ? match[1] : null;
}

/**
 * Parse a Prisma schema file and extract models and enums
 */
function parseSchemaFile(content: string): {
  models: Map<string, string>;
  enums: Map<string, string>;
} {
  const models = new Map<string, string>();
  const enums = new Map<string, string>();

  // Match model blocks
  const modelRegex = /^model\s+\w+\s*\{[\s\S]*?^\}/gm;
  const modelMatches = content.match(modelRegex) || [];
  for (const block of modelMatches) {
    const name = extractModelName(block);
    if (name) {
      models.set(name, block.trim());
    }
  }

  // Match enum blocks
  const enumRegex = /^enum\s+\w+\s*\{[\s\S]*?^\}/gm;
  const enumMatches = content.match(enumRegex) || [];
  for (const block of enumMatches) {
    const name = extractEnumName(block);
    if (name) {
      enums.set(name, block.trim());
    }
  }

  return { models, enums };
}

/**
 * Resolve schema file path based on prefix
 * - modules/ -> relative to projectRootPath
 * - core/ -> relative to projectRootPath
 * - Otherwise -> relative to coreBasePath (legacy)
 */
function resolveSchemaPath(
  projectRootPath: string,
  coreBasePath: string,
  relativePath: string
): string {
  if (relativePath.startsWith("modules/") || relativePath.startsWith("core/")) {
    return path.join(projectRootPath, relativePath);
  }
  return path.join(coreBasePath, relativePath);
}

/**
 * Read and parse a schema file
 */
async function readSchemaFile(
  fullPath: string
): Promise<{ models: Map<string, string>; enums: Map<string, string> }> {
  try {
    const content = await fs.readFile(fullPath, "utf-8");
    return parseSchemaFile(content);
  } catch (error) {
    console.warn(`Warning: Could not read schema file ${fullPath}:`, error);
    return { models: new Map(), enums: new Map() };
  }
}

/**
 * Merge multiple schema mappings into a single Prisma schema
 */
export async function mergeSchemas(
  coreBasePath: string,
  schemaMappings: SchemaMappingConfig[],
  projectRootPath?: string
): Promise<MergeResult> {
  const rootPath = projectRootPath || path.resolve(coreBasePath, "..");
  const allModels = new Map<string, string>();
  const allEnums = new Map<string, string>();

  // First, read the base schema from core
  const baseSchemaPath = path.join(coreBasePath, "backend/prisma/schema.prisma");
  const baseResult = await readSchemaFile(baseSchemaPath);

  // Add base models and enums
  for (const [name, block] of baseResult.models) {
    allModels.set(name, block);
  }
  for (const [name, block] of baseResult.enums) {
    allEnums.set(name, block);
  }

  // Process each feature's schema mappings
  for (const mapping of schemaMappings) {
    const schemaPath = resolveSchemaPath(rootPath, coreBasePath, mapping.source);
    const result = await readSchemaFile(schemaPath);

    // Add or override models
    for (const [name, block] of result.models) {
      if (!allModels.has(name)) {
        allModels.set(name, block);
      }
    }

    // Add or override enums
    for (const [name, block] of result.enums) {
      if (!allEnums.has(name)) {
        allEnums.set(name, block);
      }
    }
  }

  // Build the final schema
  let schema = BASE_SCHEMA;

  // Add enums section
  if (allEnums.size > 0) {
    schema += "// ============================================================================\n";
    schema += "// ENUMS\n";
    schema += "// ============================================================================\n\n";

    for (const [, enumBlock] of allEnums) {
      schema += enumBlock + "\n\n";
    }
  }

  // Add models section
  if (allModels.size > 0) {
    schema += "// ============================================================================\n";
    schema += "// MODELS\n";
    schema += "// ============================================================================\n\n";

    for (const [, modelBlock] of allModels) {
      schema += modelBlock + "\n\n";
    }
  }

  return {
    schema: schema.trim() + "\n",
    models: Array.from(allModels.keys()),
    enums: Array.from(allEnums.keys()),
  };
}

/**
 * Validate that all required models are present
 */
export function validateSchemaCompleteness(
  result: MergeResult,
  requiredModels: string[]
): { valid: boolean; missing: string[] } {
  const missing = requiredModels.filter((m) => !result.models.includes(m));
  return {
    valid: missing.length === 0,
    missing,
  };
}

/**
 * Generate schema from base core schema (used when no feature schema mappings)
 */
export async function generateBaseSchema(coreBasePath: string): Promise<string> {
  const result = await mergeSchemas(coreBasePath, []);
  return result.schema;
}
