/**
 * Package.json Merger Utility
 *
 * Merges package.json dependencies from multiple features into a single package.json.
 * Handles version conflicts by taking the higher semver version.
 */

import fs from "fs/promises";
import path from "path";
import semver from "semver";

export interface NpmPackageConfig {
  name: string;
  version: string;
  dev?: boolean;
}

export interface PackageJson {
  name: string;
  version: string;
  description?: string;
  main?: string;
  type?: string;
  scripts?: Record<string, string>;
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
  [key: string]: unknown;
}

export interface MergePackagesResult {
  packageJson: PackageJson;
  addedDependencies: string[];
  addedDevDependencies: string[];
  versionConflicts: Array<{
    package: string;
    selected: string;
    alternatives: string[];
  }>;
}

/**
 * Parse a semver version string, stripping any prefix characters
 */
function parseVersion(version: string): string | null {
  // Remove common prefixes like ^, ~, >=, etc.
  const cleaned = version.replace(/^[\^~>=<]+/, "");
  return semver.valid(semver.coerce(cleaned));
}

/**
 * Compare two version strings and return the higher one
 * Falls back to the first version if parsing fails
 */
function selectHigherVersion(v1: string, v2: string): string {
  const parsed1 = parseVersion(v1);
  const parsed2 = parseVersion(v2);

  if (!parsed1 || !parsed2) {
    // If we can't parse, prefer the one with more specific constraints
    return v1.startsWith("^") ? v2 : v1;
  }

  if (semver.gt(parsed1, parsed2)) {
    return v1;
  } else if (semver.gt(parsed2, parsed1)) {
    return v2;
  }

  // Same version - prefer the more flexible constraint
  return v1.startsWith("^") ? v1 : v2;
}

/**
 * Read and parse a package.json file
 */
async function readPackageJson(filePath: string): Promise<PackageJson | null> {
  try {
    const content = await fs.readFile(filePath, "utf-8");
    return JSON.parse(content) as PackageJson;
  } catch (error) {
    console.warn(`Warning: Could not read package.json at ${filePath}:`, error);
    return null;
  }
}

/**
 * Merge feature npm packages into existing dependencies
 */
export function mergeNpmPackages(
  baseDeps: Record<string, string>,
  baseDevDeps: Record<string, string>,
  featurePackages: NpmPackageConfig[]
): {
  dependencies: Record<string, string>;
  devDependencies: Record<string, string>;
  versionConflicts: Array<{
    package: string;
    selected: string;
    alternatives: string[];
  }>;
} {
  const dependencies = { ...baseDeps };
  const devDependencies = { ...baseDevDeps };
  const versionConflicts: Array<{
    package: string;
    selected: string;
    alternatives: string[];
  }> = [];

  for (const pkg of featurePackages) {
    const targetDeps = pkg.dev ? devDependencies : dependencies;
    const existing = targetDeps[pkg.name];

    if (existing) {
      // Check for version conflict
      if (existing !== pkg.version) {
        const selected = selectHigherVersion(existing, pkg.version);
        versionConflicts.push({
          package: pkg.name,
          selected,
          alternatives: [existing, pkg.version].filter((v) => v !== selected),
        });
        targetDeps[pkg.name] = selected;
      }
    } else {
      targetDeps[pkg.name] = pkg.version;
    }
  }

  return { dependencies, devDependencies, versionConflicts };
}

/**
 * Merge base package.json with feature-specific packages
 */
export async function mergePackageJson(
  coreBasePath: string,
  projectName: string,
  featurePackages: NpmPackageConfig[],
  platform: "backend" | "web" = "backend"
): Promise<MergePackagesResult> {
  // Read base package.json from core
  const basePackagePath = path.join(coreBasePath, platform, "package.json");
  const basePackage = await readPackageJson(basePackagePath);

  if (!basePackage) {
    throw new Error(`Could not read base package.json from ${basePackagePath}`);
  }

  // Merge dependencies
  const { dependencies, devDependencies, versionConflicts } = mergeNpmPackages(
    basePackage.dependencies || {},
    basePackage.devDependencies || {},
    featurePackages
  );

  // Track what was added
  const addedDependencies = featurePackages
    .filter((p) => !p.dev && !basePackage.dependencies?.[p.name])
    .map((p) => p.name);

  const addedDevDependencies = featurePackages
    .filter((p) => p.dev && !basePackage.devDependencies?.[p.name])
    .map((p) => p.name);

  // Create the merged package.json
  const packageJson: PackageJson = {
    ...basePackage,
    name: projectName,
    version: "1.0.0",
    description: `${projectName} - Generated by Xitolaunch`,
    dependencies: sortObjectKeys(dependencies),
    devDependencies: sortObjectKeys(devDependencies),
  };

  return {
    packageJson,
    addedDependencies,
    addedDevDependencies,
    versionConflicts,
  };
}

/**
 * Sort object keys alphabetically
 */
function sortObjectKeys<T>(obj: Record<string, T>): Record<string, T> {
  const sorted: Record<string, T> = {};
  for (const key of Object.keys(obj).sort()) {
    sorted[key] = obj[key];
  }
  return sorted;
}

/**
 * Generate scripts based on included features
 */
export function generateScripts(
  baseScripts: Record<string, string>,
  _features: string[]
): Record<string, string> {
  const scripts = { ...baseScripts };

  // TODO: Add feature-specific scripts based on features array
  // This can be extended based on feature requirements

  // Ensure essential scripts exist
  if (!scripts.dev) {
    scripts.dev = "tsx watch src/app.ts";
  }
  if (!scripts.build) {
    scripts.build = "tsc";
  }
  if (!scripts.start) {
    scripts.start = "node dist/app.js";
  }
  if (!scripts.lint) {
    scripts.lint = "eslint src";
  }

  // Database scripts
  if (!scripts["db:migrate"]) {
    scripts["db:migrate"] = "prisma migrate dev";
  }
  if (!scripts["db:push"]) {
    scripts["db:push"] = "prisma db push";
  }
  if (!scripts["db:generate"]) {
    scripts["db:generate"] = "prisma generate";
  }
  if (!scripts["db:seed"]) {
    scripts["db:seed"] = "tsx prisma/seed.ts";
  }

  return scripts;
}

/**
 * Convert package.json to formatted string
 */
export function stringifyPackageJson(packageJson: PackageJson): string {
  return JSON.stringify(packageJson, null, 2) + "\n";
}
